

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>最大化MicroPython速度 &mdash; handPy掌控 0.1 文档</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html">
          

          
            
            <img src="../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">handPy</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../inc/introduction.html">handPy</a></li>
</ul>
<p class="caption"><span class="caption-text">handPy快速入门教程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/class1.html">Class1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/class2.html">Class2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/class3.html">Class3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/class4.html">Class4</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../library/index.html">MicroPython 库</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../library/index.html#python-micro">Python 标准库 和 micro-库</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../library/builtins.html">内置函数和异常</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../library/builtins.html#functions-and-types">Functions and types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/builtins.html#exceptions">Exceptions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../library/array.html"><code class="docutils literal notranslate"><span class="pre">array</span></code> – 数值数组</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../library/array.html#classes">Classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../library/gc.html"><code class="docutils literal notranslate"><span class="pre">gc</span></code> –  控制垃圾收集器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../library/gc.html#functions">Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../library/math.html"><code class="docutils literal notranslate"><span class="pre">math</span></code> – 数学运算函数</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../library/math.html#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/math.html#constants">Constants</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../library/sys.html"><code class="docutils literal notranslate"><span class="pre">sys</span></code> – 系统特定功能</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../library/sys.html#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/sys.html#constants">Constants</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../library/ubinascii.html"><code class="docutils literal notranslate"><span class="pre">ubinascii</span></code> – 二进制/ ASCII转换</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../library/ubinascii.html#functions">Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../library/ucollections.html"><code class="docutils literal notranslate"><span class="pre">ucollections</span></code> – 集合和容器类型</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../library/ucollections.html#classes">Classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../library/uerrno.html"><code class="docutils literal notranslate"><span class="pre">uerrno</span></code> – 系统错误代码</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../library/uerrno.html#constants">Constants</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../library/uhashlib.html"><code class="docutils literal notranslate"><span class="pre">uhashlib</span></code> – 散列算法</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../library/uhashlib.html#constructors">Constructors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/uhashlib.html#methods">Methods</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../library/uheapq.html"><code class="docutils literal notranslate"><span class="pre">uheapq</span></code> – 堆队列算法</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../library/uheapq.html#functions">Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../library/uio.html"><code class="docutils literal notranslate"><span class="pre">uio</span></code> – 输入/输出流</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../library/uio.html#conceptual-hierarchy">Conceptual hierarchy</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/uio.html#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/uio.html#classes">Classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../library/ujson.html"><code class="docutils literal notranslate"><span class="pre">ujson</span></code> – JSON 编码和解码</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../library/ujson.html#functions">Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../library/uos.html"><code class="docutils literal notranslate"><span class="pre">uos</span></code> – 基本的“操作系统”服务</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../library/uos.html#functions">Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../library/ure.html"><code class="docutils literal notranslate"><span class="pre">ure</span></code> – 简单的正则表达式</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../library/ure.html#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/ure.html#regex-objects">Regex objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/ure.html#match-objects">Match objects</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../library/uselect.html"><code class="docutils literal notranslate"><span class="pre">uselect</span></code> – wait for events on a set of streams</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../library/uselect.html#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/uselect.html#class-poll">class <code class="docutils literal notranslate"><span class="pre">Poll</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../library/usocket.html"><code class="docutils literal notranslate"><span class="pre">usocket</span></code> – socket module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../library/usocket.html#socket-address-format-s">Socket address format(s)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/usocket.html#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/usocket.html#constants">Constants</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/usocket.html#methods">Methods</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../library/ussl.html"><code class="docutils literal notranslate"><span class="pre">ussl</span></code> – SSL/TLS module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../library/ussl.html#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/ussl.html#exceptions">Exceptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/ussl.html#constants">Constants</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../library/ustruct.html"><code class="docutils literal notranslate"><span class="pre">ustruct</span></code> – pack and unpack primitive data types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../library/ustruct.html#functions">Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../library/utime.html"><code class="docutils literal notranslate"><span class="pre">utime</span></code> – 时间相关函数</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../library/utime.html#functions">Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../library/uzlib.html"><code class="docutils literal notranslate"><span class="pre">uzlib</span></code> – zlib decompression</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../library/uzlib.html#functions">Functions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../library/index.html#id1">MicroPython-专有库</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../library/btree.html"><code class="docutils literal notranslate"><span class="pre">btree</span></code> – 简单的 BTree 数据库</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../library/btree.html#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/btree.html#methods">Methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/btree.html#constants">Constants</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../library/framebuf.html"><code class="docutils literal notranslate"><span class="pre">framebuf</span></code> — 帧缓冲操作</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../library/framebuf.html#class-framebuffer">class FrameBuffer</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/framebuf.html#constructors">Constructors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/framebuf.html#drawing-primitive-shapes">Drawing primitive shapes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/framebuf.html#drawing-text">Drawing text</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/framebuf.html#other-methods">Other methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/framebuf.html#constants">Constants</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../library/machine.html"><code class="docutils literal notranslate"><span class="pre">machine</span></code> — 与硬件相关的功能</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../library/machine.html#id1">复位相关函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/machine.html#id2">中断相关函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/machine.html#id3">电源相关函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/machine.html#id4">其他函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/machine.html#machine-constants">常量</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/machine.html#id6">类</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../library/micropython.html"><code class="docutils literal notranslate"><span class="pre">micropython</span></code> – access and control MicroPython internals</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../library/micropython.html#functions">Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../library/network.html"><code class="docutils literal notranslate"><span class="pre">network</span></code> — network configuration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../library/network.html#common-network-adapter-interface">Common network adapter interface</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../library/uctypes.html"><code class="docutils literal notranslate"><span class="pre">uctypes</span></code> – access binary data in a structured way</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../library/uctypes.html#defining-structure-layout">Defining structure layout</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/uctypes.html#module-contents">Module contents</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/uctypes.html#structure-descriptors-and-instantiating-structure-objects">Structure descriptors and instantiating structure objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/uctypes.html#structure-objects">Structure objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="../library/uctypes.html#limitations">Limitations</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">MicroPython 语法</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">MicroPython 语法</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">handPy掌控</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>最大化MicroPython速度</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/reference/speed_python.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="micropython">
<h1><a class="toc-backref" href="#id2">最大化MicroPython速度</a><a class="headerlink" href="#micropython" title="永久链接至标题">¶</a></h1>
<div class="contents topic" id="id1">
<p class="topic-title first">目录</p>
<ul class="simple">
<li><a class="reference internal" href="#micropython" id="id2">最大化MicroPython速度</a><ul>
<li><a class="reference internal" href="#designing-for-speed" id="id3">Designing for speed</a><ul>
<li><a class="reference internal" href="#algorithms" id="id4">Algorithms</a></li>
<li><a class="reference internal" href="#ram-allocation" id="id5">RAM Allocation</a></li>
<li><a class="reference internal" href="#buffers" id="id6">Buffers</a></li>
<li><a class="reference internal" href="#floating-point" id="id7">Floating Point</a></li>
<li><a class="reference internal" href="#arrays" id="id8">Arrays</a></li>
</ul>
</li>
<li><a class="reference internal" href="#identifying-the-slowest-section-of-code" id="id9">Identifying the slowest section of code</a></li>
<li><a class="reference internal" href="#micropython-code-improvements" id="id10">MicroPython code improvements</a><ul>
<li><a class="reference internal" href="#the-const-declaration" id="id11">The const() declaration</a></li>
<li><a class="reference internal" href="#caching-object-references" id="id12">Caching object references</a></li>
<li><a class="reference internal" href="#controlling-garbage-collection" id="id13">Controlling garbage collection</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-native-code-emitter" id="id14">The Native code emitter</a></li>
<li><a class="reference internal" href="#the-viper-code-emitter" id="id15">The Viper code emitter</a></li>
<li><a class="reference internal" href="#accessing-hardware-directly" id="id16">Accessing hardware directly</a></li>
</ul>
</li>
</ul>
</div>
<p>This tutorial describes ways of improving the performance of MicroPython code.
Optimisations involving other languages are covered elsewhere, namely the use
of modules written in C and the MicroPython inline assembler.</p>
<p>The process of developing high performance code comprises the following stages
which should be performed in the order listed.</p>
<ul class="simple">
<li>Design for speed.</li>
<li>Code and debug.</li>
</ul>
<p>Optimisation steps:</p>
<ul class="simple">
<li>Identify the slowest section of code.</li>
<li>Improve the efficiency of the Python code.</li>
<li>Use the native code emitter.</li>
<li>Use the viper code emitter.</li>
<li>Use hardware-specific optimisations.</li>
</ul>
<div class="section" id="designing-for-speed">
<h2><a class="toc-backref" href="#id3">Designing for speed</a><a class="headerlink" href="#designing-for-speed" title="永久链接至标题">¶</a></h2>
<p>Performance issues should be considered at the outset. This involves taking a view
on the sections of code which are most performance critical and devoting particular
attention to their design. The process of optimisation begins when the code has
been tested: if the design is correct at the outset optimisation will be
straightforward and may actually be unnecessary.</p>
<div class="section" id="algorithms">
<h3><a class="toc-backref" href="#id4">Algorithms</a><a class="headerlink" href="#algorithms" title="永久链接至标题">¶</a></h3>
<p>The most important aspect of designing any routine for performance is ensuring that
the best algorithm is employed. This is a topic for textbooks rather than for a
MicroPython guide but spectacular performance gains can sometimes be achieved
by adopting algorithms known for their efficiency.</p>
</div>
<div class="section" id="ram-allocation">
<h3><a class="toc-backref" href="#id5">RAM Allocation</a><a class="headerlink" href="#ram-allocation" title="永久链接至标题">¶</a></h3>
<p>To design efficient MicroPython code it is necessary to have an understanding of the
way the interpreter allocates RAM. When an object is created or grows in size
(for example where an item is appended to a list) the necessary RAM is allocated
from a block known as the heap. This takes a significant amount of time;
further it will on occasion trigger a process known as garbage collection which
can take several milliseconds.</p>
<p>Consequently the performance of a function or method can be improved if an object is created
once only and not permitted to grow in size. This implies that the object persists
for the duration of its use: typically it will be instantiated in a class constructor
and used in various methods.</p>
<p>This is covered in further detail <a class="reference internal" href="#controlling-gc"><span class="std std-ref">Controlling garbage collection</span></a> below.</p>
</div>
<div class="section" id="buffers">
<h3><a class="toc-backref" href="#id6">Buffers</a><a class="headerlink" href="#buffers" title="永久链接至标题">¶</a></h3>
<p>An example of the above is the common case where a buffer is required, such as one
used for communication with a device. A typical driver will create the buffer in the
constructor and use it in its I/O methods which will be called repeatedly.</p>
<p>The MicroPython libraries typically provide support for pre-allocated buffers. For
example, objects which support stream interface (e.g., file or UART) provide <cite>read()</cite>
method which allocates new buffer for read data, but also a <cite>readinto()</cite> method
to read data into an existing buffer.</p>
</div>
<div class="section" id="floating-point">
<h3><a class="toc-backref" href="#id7">Floating Point</a><a class="headerlink" href="#floating-point" title="永久链接至标题">¶</a></h3>
<p>Some MicroPython ports allocate floating point numbers on heap. Some other ports
may lack dedicated floating-point coprocessor, and perform arithmetic operations
on them in “software” at considerably lower speed than on integers. Where
performance is important, use integer operations and restrict the use of floating
point to sections of the code where performance is not paramount. For example,
capture ADC readings as integers values to an array in one quick go, and only then
convert them to floating-point numbers for signal processing.</p>
</div>
<div class="section" id="arrays">
<h3><a class="toc-backref" href="#id8">Arrays</a><a class="headerlink" href="#arrays" title="永久链接至标题">¶</a></h3>
<p>Consider the use of the various types of array classes as an alternative to lists.
The <cite>array</cite> module supports various element types with 8-bit elements supported
by Python’s built in <cite>bytes</cite> and <cite>bytearray</cite> classes. These data structures all store
elements in contiguous memory locations. Once again to avoid memory allocation in critical
code these should be pre-allocated and passed as arguments or as bound objects.</p>
<p>When passing slices of objects such as <cite>bytearray</cite> instances, Python creates
a copy which involves allocation of the size proportional to the size of slice.
This can be alleviated using a <cite>memoryview</cite> object. <cite>memoryview</cite> itself
is allocated on heap, but is a small, fixed-size object, regardless of the size
of slice it points too.</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ba</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>  <span class="c1"># big array</span>
<span class="n">func</span><span class="p">(</span><span class="n">ba</span><span class="p">[</span><span class="mi">30</span><span class="p">:</span><span class="mi">2000</span><span class="p">])</span>      <span class="c1"># a copy is passed, ~2K new allocation</span>
<span class="n">mv</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">ba</span><span class="p">)</span>    <span class="c1"># small object is allocated</span>
<span class="n">func</span><span class="p">(</span><span class="n">mv</span><span class="p">[</span><span class="mi">30</span><span class="p">:</span><span class="mi">2000</span><span class="p">])</span>      <span class="c1"># a pointer to memory is passed</span>
</pre></div>
</div>
<p>A <cite>memoryview</cite> can only be applied to objects supporting the buffer protocol - this
includes arrays but not lists. Small caveat is that while memoryview object is live,
it also keeps alive the original buffer object. So, a memoryview isn’t a universal
panacea. For instance, in the example above, if you are done with 10K buffer and
just need those bytes 30:2000 from it, it may be better to make a slice, and let
the 10K buffer go (be ready for garbage collection), instead of making a
long-living memoryview and keeping 10K blocked for GC.</p>
<p>Nonetheless, <cite>memoryview</cite> is indispensable for advanced preallocated buffer
management. <cite>readinto()</cite> method discussed above puts data at the beginning
of buffer and fills in entire buffer. What if you need to put data in the
middle of existing buffer? Just create a memoryview into the needed section
of buffer and pass it to <cite>readinto()</cite>.</p>
</div>
</div>
<div class="section" id="identifying-the-slowest-section-of-code">
<h2><a class="toc-backref" href="#id9">Identifying the slowest section of code</a><a class="headerlink" href="#identifying-the-slowest-section-of-code" title="永久链接至标题">¶</a></h2>
<p>This is a process known as profiling and is covered in textbooks and
(for standard Python) supported by various software tools. For the type of
smaller embedded application likely to be running on MicroPython platforms
the slowest function or method can usually be established by judicious use
of the timing <code class="docutils literal notranslate"><span class="pre">ticks</span></code> group of functions documented in <cite>utime</cite>.
Code execution time can be measured in ms, us, or CPU cycles.</p>
<p>The following enables any function or method to be timed by adding an
<code class="docutils literal notranslate"><span class="pre">&#64;timed_function</span></code> decorator:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">timed_function</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">myname</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">new_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">utime</span><span class="o">.</span><span class="n">ticks_us</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">utime</span><span class="o">.</span><span class="n">ticks_diff</span><span class="p">(</span><span class="n">utime</span><span class="o">.</span><span class="n">ticks_us</span><span class="p">(),</span> <span class="n">t</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Function </span><span class="si">{}</span><span class="s1"> Time = </span><span class="si">{:6.3f}</span><span class="s1">ms&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">myname</span><span class="p">,</span> <span class="n">delta</span><span class="o">/</span><span class="mi">1000</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">new_func</span>
</pre></div>
</div>
</div>
<div class="section" id="micropython-code-improvements">
<h2><a class="toc-backref" href="#id10">MicroPython code improvements</a><a class="headerlink" href="#micropython-code-improvements" title="永久链接至标题">¶</a></h2>
<div class="section" id="the-const-declaration">
<h3><a class="toc-backref" href="#id11">The const() declaration</a><a class="headerlink" href="#the-const-declaration" title="永久链接至标题">¶</a></h3>
<p>MicroPython provides a <code class="docutils literal notranslate"><span class="pre">const()</span></code> declaration. This works in a similar way
to <code class="docutils literal notranslate"><span class="pre">#define</span></code> in C in that when the code is compiled to bytecode the compiler
substitutes the numeric value for the identifier. This avoids a dictionary
lookup at runtime. The argument to <code class="docutils literal notranslate"><span class="pre">const()</span></code> may be anything which, at
compile time, evaluates to an integer e.g. <code class="docutils literal notranslate"><span class="pre">0x100</span></code> or <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;&lt;</span> <span class="pre">8</span></code>.</p>
</div>
<div class="section" id="caching-object-references">
<span id="caching"></span><h3><a class="toc-backref" href="#id12">Caching object references</a><a class="headerlink" href="#caching-object-references" title="永久链接至标题">¶</a></h3>
<p>Where a function or method repeatedly accesses objects performance is improved
by caching the object in a local variable:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ba</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj_display</span><span class="p">):</span>
        <span class="n">ba_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ba</span>
        <span class="n">fb</span> <span class="o">=</span> <span class="n">obj_display</span><span class="o">.</span><span class="n">framebuffer</span>
        <span class="c1"># iterative code using these two objects</span>
</pre></div>
</div>
<p>This avoids the need repeatedly to look up <code class="docutils literal notranslate"><span class="pre">self.ba</span></code> and <code class="docutils literal notranslate"><span class="pre">obj_display.framebuffer</span></code>
in the body of the method <code class="docutils literal notranslate"><span class="pre">bar()</span></code>.</p>
</div>
<div class="section" id="controlling-garbage-collection">
<span id="controlling-gc"></span><h3><a class="toc-backref" href="#id13">Controlling garbage collection</a><a class="headerlink" href="#controlling-garbage-collection" title="永久链接至标题">¶</a></h3>
<p>When memory allocation is required, MicroPython attempts to locate an adequately
sized block on the heap. This may fail, usually because the heap is cluttered
with objects which are no longer referenced by code. If a failure occurs, the
process known as garbage collection reclaims the memory used by these redundant
objects and the allocation is then tried again - a process which can take several
milliseconds.</p>
<p>There may be benefits in pre-empting this by periodically issuing <cite>gc.collect()</cite>.
Firstly doing a collection before it is actually required is quicker - typically on the
order of 1ms if done frequently. Secondly you can determine the point in code
where this time is used rather than have a longer delay occur at random points,
possibly in a speed critical section. Finally performing collections regularly
can reduce fragmentation in the heap. Severe fragmentation can lead to
non-recoverable allocation failures.</p>
</div>
</div>
<div class="section" id="the-native-code-emitter">
<h2><a class="toc-backref" href="#id14">The Native code emitter</a><a class="headerlink" href="#the-native-code-emitter" title="永久链接至标题">¶</a></h2>
<p>This causes the MicroPython compiler to emit native CPU opcodes rather than
bytecode. It covers the bulk of the MicroPython functionality, so most functions will require
no adaptation (but see below). It is invoked by means of a function decorator:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@micropython</span><span class="o">.</span><span class="n">native</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
    <span class="n">buf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linebuf</span> <span class="c1"># Cached object</span>
    <span class="c1"># code</span>
</pre></div>
</div>
<p>There are certain limitations in the current implementation of the native code emitter.</p>
<ul class="simple">
<li>Context managers are not supported (the <code class="docutils literal notranslate"><span class="pre">with</span></code> statement).</li>
<li>Generators are not supported.</li>
<li>If <code class="docutils literal notranslate"><span class="pre">raise</span></code> is used an argument must be supplied.</li>
</ul>
<p>The trade-off for the improved performance (roughly twices as fast as bytecode) is an
increase in compiled code size.</p>
</div>
<div class="section" id="the-viper-code-emitter">
<h2><a class="toc-backref" href="#id15">The Viper code emitter</a><a class="headerlink" href="#the-viper-code-emitter" title="永久链接至标题">¶</a></h2>
<p>The optimisations discussed above involve standards-compliant Python code. The
Viper code emitter is not fully compliant. It supports special Viper native data types
in pursuit of performance. Integer processing is non-compliant because it uses machine
words: arithmetic on 32 bit hardware is performed modulo 2**32.</p>
<p>Like the Native emitter Viper produces machine instructions but further optimisations
are performed, substantially increasing performance especially for integer arithmetic and
bit manipulations. It is invoked using a decorator:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@micropython</span><span class="o">.</span><span class="n">viper</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># code</span>
</pre></div>
</div>
<p>As the above fragment illustrates it is beneficial to use Python type hints to assist the Viper optimiser.
Type hints provide information on the data types of arguments and of the return value; these
are a standard Python language feature formally defined here <a class="reference external" href="https://www.python.org/dev/peps/pep-0484/">PEP0484</a>.
Viper supports its own set of types namely <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">uint</span></code> (unsigned integer), <code class="docutils literal notranslate"><span class="pre">ptr</span></code>, <code class="docutils literal notranslate"><span class="pre">ptr8</span></code>,
<code class="docutils literal notranslate"><span class="pre">ptr16</span></code> and <code class="docutils literal notranslate"><span class="pre">ptr32</span></code>. The <code class="docutils literal notranslate"><span class="pre">ptrX</span></code> types are discussed below. Currently the <code class="docutils literal notranslate"><span class="pre">uint</span></code> type serves
a single purpose: as a type hint for a function return value. If such a function returns <code class="docutils literal notranslate"><span class="pre">0xffffffff</span></code>
Python will interpret the result as 2**32 -1 rather than as -1.</p>
<p>In addition to the restrictions imposed by the native emitter the following constraints apply:</p>
<ul class="simple">
<li>Functions may have up to four arguments.</li>
<li>Default argument values are not permitted.</li>
<li>Floating point may be used but is not optimised.</li>
</ul>
<p>Viper provides pointer types to assist the optimiser. These comprise</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">ptr</span></code> Pointer to an object.</li>
<li><code class="docutils literal notranslate"><span class="pre">ptr8</span></code> Points to a byte.</li>
<li><code class="docutils literal notranslate"><span class="pre">ptr16</span></code> Points to a 16 bit half-word.</li>
<li><code class="docutils literal notranslate"><span class="pre">ptr32</span></code> Points to a 32 bit machine word.</li>
</ul>
<p>The concept of a pointer may be unfamiliar to Python programmers. It has similarities
to a Python <cite>memoryview</cite> object in that it provides direct access to data stored in memory.
Items are accessed using subscript notation, but slices are not supported: a pointer can return
a single item only. Its purpose is to provide fast random access to data stored in contiguous
memory locations - such as data stored in objects which support the buffer protocol, and
memory-mapped peripheral registers in a microcontroller. It should be noted that programming
using pointers is hazardous: bounds checking is not performed and the compiler does nothing to
prevent buffer overrun errors.</p>
<p>Typical usage is to cache variables:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@micropython</span><span class="o">.</span><span class="n">viper</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">buf</span> <span class="o">=</span> <span class="n">ptr8</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">linebuf</span><span class="p">)</span> <span class="c1"># self.linebuf is a bytearray or bytes object</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">):</span>
        <span class="n">bar</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="c1"># Access a data item through the pointer</span>
        <span class="c1"># code omitted</span>
</pre></div>
</div>
<p>In this instance the compiler “knows” that <code class="docutils literal notranslate"><span class="pre">buf</span></code> is the address of an array of bytes;
it can emit code to rapidly compute the address of <code class="docutils literal notranslate"><span class="pre">buf[x]</span></code> at runtime. Where casts are
used to convert objects to Viper native types these should be performed at the start of
the function rather than in critical timing loops as the cast operation can take several
microseconds. The rules for casting are as follows:</p>
<ul class="simple">
<li>Casting operators are currently: <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">bool</span></code>, <code class="docutils literal notranslate"><span class="pre">uint</span></code>, <code class="docutils literal notranslate"><span class="pre">ptr</span></code>, <code class="docutils literal notranslate"><span class="pre">ptr8</span></code>, <code class="docutils literal notranslate"><span class="pre">ptr16</span></code> and <code class="docutils literal notranslate"><span class="pre">ptr32</span></code>.</li>
<li>The result of a cast will be a native Viper variable.</li>
<li>Arguments to a cast can be a Python object or a native Viper variable.</li>
<li>If argument is a native Viper variable, then cast is a no-op (i.e. costs nothing at runtime)
that just changes the type (e.g. from <code class="docutils literal notranslate"><span class="pre">uint</span></code> to <code class="docutils literal notranslate"><span class="pre">ptr8</span></code>) so that you can then store/load
using this pointer.</li>
<li>If the argument is a Python object and the cast is <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code>, then the Python object
must be of integral type and the value of that integral object is returned.</li>
<li>The argument to a bool cast must be integral type (boolean or integer); when used as a return
type the viper function will return True or False objects.</li>
<li>If the argument is a Python object and the cast is <code class="docutils literal notranslate"><span class="pre">ptr</span></code>, <code class="docutils literal notranslate"><span class="pre">ptr</span></code>, <code class="docutils literal notranslate"><span class="pre">ptr16</span></code> or <code class="docutils literal notranslate"><span class="pre">ptr32</span></code>,
then the Python object must either have the buffer protocol with read-write capabilities
(in which case a pointer to the start of the buffer is returned) or it must be of integral
type (in which case the value of that integral object is returned).</li>
</ul>
<p>The following example illustrates the use of a <code class="docutils literal notranslate"><span class="pre">ptr16</span></code> cast to toggle pin X1 <code class="docutils literal notranslate"><span class="pre">n</span></code> times:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BIT0</span> <span class="o">=</span> <span class="n">const</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="nd">@micropython</span><span class="o">.</span><span class="n">viper</span>
<span class="k">def</span> <span class="nf">toggle_n</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">odr</span> <span class="o">=</span> <span class="n">ptr16</span><span class="p">(</span><span class="n">stm</span><span class="o">.</span><span class="n">GPIOA</span> <span class="o">+</span> <span class="n">stm</span><span class="o">.</span><span class="n">GPIO_ODR</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">odr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">^=</span> <span class="n">BIT0</span>
</pre></div>
</div>
<p>A detailed technical description of the three code emitters may be found
on Kickstarter here <a class="reference external" href="https://www.kickstarter.com/projects/214379695/micro-python-python-for-microcontrollers/posts/664832">Note 1</a>
and here <a class="reference external" href="https://www.kickstarter.com/projects/214379695/micro-python-python-for-microcontrollers/posts/665145">Note 2</a></p>
</div>
<div class="section" id="accessing-hardware-directly">
<h2><a class="toc-backref" href="#id16">Accessing hardware directly</a><a class="headerlink" href="#accessing-hardware-directly" title="永久链接至标题">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">Code examples in this section are given for the Pyboard. The techniques
described however may be applied to other MicroPython ports too.</p>
</div>
<p>This comes into the category of more advanced programming and involves some knowledge
of the target MCU. Consider the example of toggling an output pin on the Pyboard. The
standard approach would be to write</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mypin</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">mypin</span><span class="o">.</span><span class="n">value</span><span class="p">()</span> <span class="o">^</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># mypin was instantiated as an output pin</span>
</pre></div>
</div>
<p>This involves the overhead of two calls to the <cite>Pin</cite> instance’s <a class="reference internal" href="../library/machine.Pin.html#machine.Pin.value" title="machine.Pin.value"><code class="xref py py-meth docutils literal notranslate"><span class="pre">value()</span></code></a>
method. This overhead can be eliminated by performing a read/write to the relevant bit
of the chip’s GPIO port output data register (odr). To facilitate this the <code class="docutils literal notranslate"><span class="pre">stm</span></code>
module provides a set of constants providing the addresses of the relevant registers.
A fast toggle of pin <code class="docutils literal notranslate"><span class="pre">P4</span></code> (CPU pin <code class="docutils literal notranslate"><span class="pre">A14</span></code>) - corresponding to the green LED -
can be performed as follows:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">machine</span>
<span class="kn">import</span> <span class="nn">stm</span>

<span class="n">BIT14</span> <span class="o">=</span> <span class="n">const</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">)</span>
<span class="n">machine</span><span class="o">.</span><span class="n">mem16</span><span class="p">[</span><span class="n">stm</span><span class="o">.</span><span class="n">GPIOA</span> <span class="o">+</span> <span class="n">stm</span><span class="o">.</span><span class="n">GPIO_ODR</span><span class="p">]</span> <span class="o">^=</span> <span class="n">BIT14</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, labplus.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.1',
            LANGUAGE:'zh_CN',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/translations.js"></script>

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>